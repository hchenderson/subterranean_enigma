
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model that segregates administrative users from game participants. All data is private by default, and a user (whether an admin or participant) can only access documents that are directly associated with their unique user ID (UID).
 *
 * Data Structure: The data is organized into three primary top-level collections: `/admins` for administrators, `/games` for game-specific data like hints and materials, and `/participants` for game players. A participant's game progress is stored in a nested subcollection, `/participants/{participantId}/gameState`, ensuring that all of a user's data is contained within a single, securable data tree.
 *
 * Key Security Decisions:
 * - Strict Segregation: Admins and Participants are stored in separate collections to prevent any overlap in access rules.
 * - Ownership-Based Access: All rules for participant data are based on the principle that the authenticated user's UID must match the document ID in the path (e.g., `{participantId}`).
 * - Admin Access to Game Data: Authenticated, non-anonymous users (admins) have full access to the `/games` collection, which is necessary for them to manage game content like hints and materials.
 * - No Public Listing: It is impossible for participants to list all admins, all participants, or game-wide data. A user can only list documents within their own subcollections (e.g., their own `gameState`).
 * - Default Deny: Access is denied by default. All permissions must be explicitly granted.
 *
 * Denormalization for Authorization: The structure `/participants/{participantId}/gameState` uses the path itself as the primary authorization mechanism. This avoids the need for costly `get()` calls to a parent document when securing the `gameState` subcollection.
 *
 * Public Validation Collection: The `/games/{gameId}/participants` collection is readable by anyone. This is a deliberate design choice to allow an unauthenticated user to validate an entry code *before* they sign in. This collection should ONLY store the code itself and no sensitive information.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Returns true if the user is a logged-in admin (not anonymous).
     */
    function isAdmin() {
      return isSignedIn() && request.auth.token.firebase.sign_in_provider != "anonymous";
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * This is the core of the ownership model.
     * @param userId The UID of the document owner.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Validates that the AdminUser document being created contains an 'id' field
     * that matches the document's ID in the path, ensuring relational integrity.
     * @param adminId The document ID from the Firestore path.
     */
    function isCreatingOwnAdminDoc(adminId) {
      return request.resource.data.id == adminId;
    }

    /**
     * Enforces immutability for the critical 'id' field on an AdminUser document
     * during an update operation, preventing ownership from being changed.
     */
    function isAdminDocImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that the ParticipantUser document being created contains an 'id'
     * field that matches the document's ID, ensuring relational integrity.
     * @param participantId The document ID from the Firestore path.
     */
    function isCreatingOwnParticipantDoc(participantId) {
      return request.resource.data.id == participantId;
    }

    /**
     * Enforces immutability for the critical 'id' field on a ParticipantUser document.
     */
    function isParticipantDocImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that the GameState document being created has a 'participantUserId'
     * that correctly links it back to its parent participant document.
     * @param participantId The parent participant's ID from the Firestore path.
     */
    function isCreatingValidGameState(participantId) {
      return request.resource.data.participantUserId == participantId;
    }

    /**
     * Enforces immutability for the critical 'participantUserId' field on a
     * GameState document, preventing the record from being moved between users.
     */
    function isGameStateImmutable() {
      return request.resource.data.participantUserId == resource.data.participantUserId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Secures admin user profile documents. Only the owner of the document can read, create, update, or delete it. Listing all admins is disabled.
     * @path /admins/{adminId}
     */
    match /admins/{adminId} {
      allow get, update, delete: if isOwner(adminId);
      allow create: if isOwner(adminId) && isCreatingOwnAdminDoc(adminId);
      allow list: if false;
    }
    
    /**
     * @description Secures game-wide data. Admins have full control. Participants have no access.
     * @path /games/{gameId}
     */
    match /games/{gameId} {
      allow read, write: if isAdmin();
      
      // Allow anyone to read the participant codes for validation purposes.
      // This collection should ONLY contain the codes themselves.
      match /participants/{participantId} {
        allow read: if true;
        allow write: if isAdmin();
      }

      // Admins have full control over all subcollections within a game.
      match /{allChildren=**} {
        allow read, write: if isAdmin();
      }
    }

    /**
     * @description Secures participant user profile documents. A participant can only create and manage their own document.
     * @path /participants/{participantId}
     */
    match /participants/{participantId} {
      allow get, update, delete: if isOwner(participantId);
      allow create: if isOwner(participantId) && isCreatingOwnParticipantDoc(participantId);
      allow list: if false; // Participants cannot list other participants

      /**
       * @description Secures the game state for each participant. A participant can only access the game state stored within their own document tree.
       * @path /participants/{participantId}/gameState/{gameStateId}
       */
      match /gameState/{gameStateId} {
        allow get, list, update, delete: if isOwner(participantId);
        allow create: if isOwner(participantId) && isCreatingValidGameState(participantId);
      }
    }
  }
}
